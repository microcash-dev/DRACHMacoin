/* ASHITE MEDRAWS and AKEEP FAATING */
unsigned int static GetNextWorkRequired_VS(const CBlockIndex* pindexLast, const CBlockHeader *pblock, int algo)
{
    unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit(algo).GetCompact();
    bool fTestNet;
    fTestNet = TestNet();
    
    // Genesis block
    if (pindexLast == NULL)
        return nProofOfWorkLimit;
    
    const CBlockIndex* pindex = pindexLast;
    
    // Testnet
    if (fTestNet)
    {

        // Special difficulty rule for testnet:
        // If the new block's timestamp is more than 2* 10 minutes
        // then allow mining of a min-difficulty block.
        if(pindex->nHeight < DIFF_SWITCH_BLOCK_2)
        {
            nTargetSpacingSwitch = nTargetSpacing;
        }
        else
        {
            nTargetSpacingSwitch = nTargetSpacingNEW;
        }
        if (pblock->nTime > pindexLast->nTime + nTargetSpacingSwitch*2)
            return nProofOfWorkLimit;
        else
        {
            // Return the last non-special-min-difficulty-rules-block
            
            while (pindex->pprev && pindex->nHeight % nInterval != 0 && pindex->nBits == nProofOfWorkLimit)
                pindex = pindex->pprev;
            return pindex->nBits;
        }
    }

    // find previous block with same algo
    const CBlockIndex* pindexPrev = GetLastBlockIndexForAlgo(pindexLast, algo);
    
    // find first block in averaging interval
    // Go back by what we want to be nAveragingInterval blocks
    const CBlockIndex* pindexFirst = pindexPrev;
    for (int i = 0; pindexFirst && i < nAveragingInterval - 1; i++)
    {
        pindexFirst = pindexFirst->pprev;
        pindexFirst = GetLastBlockIndexForAlgo(pindexFirst, algo);
    }
    if (pindexFirst == NULL)
        return nProofOfWorkLimit; // not nAveragingInterval blocks of this algo available

    // Limit adjustment step
    int64 nActualTimespan = pindexPrev->GetBlockTime() - pindexFirst->GetBlockTime();
    printf("  nActualTimespan = %"PRI64d"  before bounds\n", nActualTimespan);
    if(pindex->nHeight < DIFF_SWITCH_BLOCK_2)
        {
            if (nActualTimespan < nMinActualTimespan)
            nActualTimespan = nMinActualTimespan;
            if (nActualTimespan > nMaxActualTimespan)
            nActualTimespan = nMaxActualTimespan;
        }
        else
        {
            if (nActualTimespan < nMinActualTimespanNEW)
            nActualTimespan = nMinActualTimespanNEW;
            if (nActualTimespan > nMaxActualTimespanNEW)
            nActualTimespan = nMaxActualTimespanNEW;
        }
    

    // Retarget
    CBigNum bnNew;
    bnNew.SetCompact(pindexPrev->nBits);
    bnNew *= nActualTimespan;
    if(pindex->nHeight < DIFF_SWITCH_BLOCK_2)
    bnNew /= nAveragingTargetTimespan;
    else
    bnNew /= nAveragingTargetTimespanNEW;

    if (bnNew > Params().ProofOfWorkLimit(algo))
        bnNew = Params().ProofOfWorkLimit(algo);

    /// debug print
    printf("GetNextWorkRequired->Normal RETARGET\n");

    if(pindex->nHeight < DIFF_SWITCH_BLOCK_2)
    printf("nTargetTimespan = %"PRI64d"    nActualTimespan = %"PRI64d"\n", nAveragingTargetTimespan, nActualTimespan);
    else
    printf("nTargetTimespan = %"PRI64d"    nActualTimespan = %"PRI64d"\n", nAveragingTargetTimespanNEW, nActualTimespan);

    printf("Before: %08x  %s\n", pindexPrev->nBits, CBigNum().SetCompact(pindexPrev->nBits).getuint256().ToString().c_str());
    printf("After:  %08x  %s\n", bnNew.GetCompact(), bnNew.getuint256().ToString().c_str());

    return bnNew.GetCompact();
}

